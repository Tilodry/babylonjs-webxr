<!DOCTYPE html>
<html>
<head>
    <title>BabylonJS Project</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
</head>
<body>
    <canvas id="renderCanvas" style="width: 100%; height: 100%;"></canvas>
    <script type="text/javascript">
        let canvas, engine, scene, gizmoManager, project;

        window.onload = function () {
            canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            init();
        };

        async function init() {
            project = new Project("MonProjet", [
                new Scene("Scene1"),
                new Scene("Scene2")
            ]);
            await project.switchScene("Scene1");
            setupUI();

            engine.runRenderLoop(() => {
                if (scene && scene.activeCamera) {
                    scene.render();
                }
            });
        }

        class Scene {
            constructor(name) {
                this.name = name;
            }

            async load() {
                scene = new BABYLON.Scene(engine);
                scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.CannonJSPlugin());
                scene.clearColor = new BABYLON.Color3.Black();

                let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, -0.5), scene);
                let camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 3, -10), scene);
                camera.attachControl(canvas, true);

                this.initializeGizmoManager();
                this.addObjects();
            }

            async loadExisting() {
                scene = this;
            }

            initializeGizmoManager() {
                gizmoManager = new BABYLON.GizmoManager(scene);
                gizmoManager.boundingBoxGizmoEnabled = true;
            }

            addObjects() {
                let ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 30, height: 30 });
                ground.position.y = -5;
                this.importGLTF("GL/Duck.glb");
                this.importGLTF("GL/AnimatedCube.gltf");
            }

            async importGLTF(gltfPath) {
                await BABYLON.SceneLoader.ImportMeshAsync("", gltfPath, "", scene).then((result) => {
                    if (gizmoManager.attachableMeshes != null) {
                        gizmoManager.attachableMeshes.push(...result.meshes);
                    }
                    else {
                        gizmoManager.attachableMeshes = result.meshes;
                    }
                });
            }
        }

        class Project {
            constructor(name, scenes) {
                this.name = name;
                this.scenes = scenes;
                this.currentScene = null;
            }

            async switchScene(sceneName) {
                if (this.currentScene) {
                    // Clean up or unload previous scene if needed
                }
                const newScene = this.scenes.find(scene => scene.name === sceneName);
                if (newScene) {
                    await newScene.load();
                    this.currentScene = newScene;
                    setupUI();
                }
            }
        }

        function setupUI() {
            const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

            // Champ de texte pour le chemin GLTF/GLB
            const gltfPathInput = new BABYLON.GUI.InputText();
            gltfPathInput.width = 0.2;
            gltfPathInput.maxWidth = 0.2;
            gltfPathInput.height = "40px";
            gltfPathInput.color = "white";
            gltfPathInput.background = "black";
            gltfPathInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            gltfPathInput.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            gltfPathInput.left = "25px";
            gltfPathInput.top = "25px";
            gltfPathInput.placeholderText = "Enter GLTF/Glb path...";
            advancedTexture.addControl(gltfPathInput);

            // Bouton d'importation GLTF/GLB
            const importButton = BABYLON.GUI.Button.CreateSimpleButton("importButton", "Import GLTF");
            importButton.width = 0.2;
            importButton.height = "40px";
            importButton.color = "white";
            importButton.background = "black";
            importButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            importButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            importButton.left = "25px";
            importButton.top = "75px";
            importButton.onPointerClickObservable.add(() => {
                if (project.currentScene) {
                    project.currentScene.importGLTF(gltfPathInput.text);
                }
            });
            advancedTexture.addControl(importButton);

            // Champ de texte pour le nom de la scène à charger
            const sceneNameInput = new BABYLON.GUI.InputText();
            sceneNameInput.width = 0.2;
            sceneNameInput.maxWidth = 0.2;
            sceneNameInput.height = "40px";
            sceneNameInput.color = "white";
            sceneNameInput.background = "black";
            sceneNameInput.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            sceneNameInput.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            sceneNameInput.left = "25px";
            sceneNameInput.top = "125px";
            sceneNameInput.placeholderText = "Enter scene name...";
            advancedTexture.addControl(sceneNameInput);

            // Bouton pour changer de scène
            const switchSceneButton = BABYLON.GUI.Button.CreateSimpleButton("switchSceneButton", "Switch Scene");
            switchSceneButton.width = 0.2;
            switchSceneButton.height = "40px";
            switchSceneButton.color = "white";
            switchSceneButton.background = "black";
            switchSceneButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
            switchSceneButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            switchSceneButton.left = "25px";
            switchSceneButton.top = "175px";
            switchSceneButton.onPointerClickObservable.add(async () => {
                await project.switchScene(sceneNameInput.text);
            });
            advancedTexture.addControl(switchSceneButton);
        }
        /*
        function serializeScene() {
            // Sérialiser la scène
            var serializedScene = BABYLON.SceneSerializer.Serialize(scene);

            // Parcourir tous les meshes pour ajouter les métadonnées manuellement
            serializedScene.meshes.forEach((mesh, index) => {
                if (scene.meshes[index].metadata) {
                    mesh.metadata = scene.meshes[index].metadata;
                }
            });

            // Convertir l'objet sérialisé en chaîne JSON pour le stockage ou le transfert
            var serializedSceneAsString = JSON.stringify(serializedScene);
            console.log(serializedSceneAsString);
            return serializedSceneAsString;
        }

        function deserializeScene(serializedSceneAsString) {
            // Convertir la chaîne JSON en objet
            var serializedScene = JSON.parse(serializedSceneAsString);

            // Créer une nouvelle scène vide
            var newScene = new BABYLON.Scene(engine);

            // Désérialiser l'objet dans la nouvelle scène
            BABYLON.SceneLoader.Load("", "data:" + serializedSceneAsString, engine, function (loadedScene) {
                // La scène est maintenant chargée, vous pouvez vérifier les métadonnées ici
                loadedScene.meshes.forEach(mesh => {
                    if (mesh.metadata) {
                        console.log("Metadata for mesh", mesh.name, ":", mesh.metadata);
                    }
                });
            });
        }
        */
    </script>
</body>
</html>
